<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>F!RST — v18</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <style>
    :root {
      --zone-k: 0.78;
      --zone-c: 20px;
      --page-max: 1280px;
      --bg: #0c1014;
      --panel-b: #232b39;
      --text: #f2f5fb;
      --muted: #aab3c2;
      --accent: #8fb1ff;
      --outline: #4a5a84;
      --ring: #3aa1ff80;
      --forbid: #ffd36b;
      --card-w: clamp(84px, 11vw, 112px);
      --card-w-hand: var(--card-w);
      --gap: 12px;
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100svh;
      height: 100dvh;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
      overscroll-behavior: none
    }

    .wrap {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden
    }

    .center {
      max-width: var(--page-max);
      margin: 0 auto;
      position: relative
    }

    /* ===== Header ===== */
    header {
      position: sticky;
      top: 0;
      z-index: 120;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 8px 14px;
      background: linear-gradient(180deg, #0c1014, #0c1014cc 80%, transparent);
      backdrop-filter: saturate(110%) blur(4px)
    }

    header .center {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      width: 100%
    }

    .titlebar {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
      white-space: nowrap;
      overflow-x: auto;
      scrollbar-width: none
    }

    .titlebar::-webkit-scrollbar {
      display: none
    }

    h1 {
      font-size: 18px;
      margin: 0;
      color: var(--accent);
      white-space: nowrap
    }

    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--panel-b);
      background: #0f1422b3;
      color: #dae6ff;
      font-size: 12px;
      backdrop-filter: blur(4px);
      white-space: nowrap
    }

    .btn {
      background: #1a2233;
      color: var(--text);
      border: 1px solid var(--panel-b);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer
    }

    .btn:hover {
      background: #1f2a40
    }

    .icon-btn {
      width: 34px;
      height: 34px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center
    }

    #hamburger {
      display: none;
      width: 40px;
      height: 36px;
      border-radius: 10px;
      font-weight: 900
    }

    .quickMenu {
      position: fixed;
      right: 10px;
      top: 54px;
      display: none;
      flex-direction: column;
      gap: 8px;
      background: #0f1728;
      border: 1px solid #2d3754;
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 16px 36px rgba(0, 0, 0, .55);
      z-index: 300
    }

    .quickMenu .btn {
      width: 200px;
      text-align: left
    }

    /* ===== Layout ===== */
    .boardShell {
      position: relative;
      flex: 1;
      overflow: hidden
    }

    .boardGrid {
      position: absolute;
      inset: 48px 0 0 0;
      display: grid;
      grid-template-columns: 1fr minmax(260px, 320px);
      gap: var(--gap);
      overflow: hidden;
      padding: 0 var(--gap) var(--gap) var(--gap);
      transform-origin: top left
    }

    .leftCol {
      display: grid;
      grid-template-rows: auto auto auto;
      gap: var(--gap);
      min-width: 0;
      min-height: 0
    }

    .rightCol {
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: var(--gap);
      min-width: 0;
      min-height: 0
    }

    .panel {
      background: radial-gradient(500px 280px at 50% -10%, #16213a, #0e1420 70%);
      border: 1px solid #2a3550;
      border-radius: 14px;
      padding: 10px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, .30), 0 0 0 1px #0b1220 inset, 0 0 24px #1a2b5533 inset;
      overflow: hidden;
      min-height: 0;
      display: flex;
      flex-direction: column
    }

    .title {
      font-weight: 800;
      margin-bottom: 6px;
      font-size: 13px;
      color: #dbe5ff;
      letter-spacing: .3px;
      text-shadow: 0 1px 0 #000;
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap
    }

    .chip {
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid #2f3a56;
      border-radius: 999px;
      background: #101828;
      color: #dbe5ff
    }

    .note {
      font-size: 12px;
      color: var(--muted)
    }

    /* Space panels */
    .boardFlat {
      position: relative;
      width: 100%;
      border-radius: 14px;
      background: linear-gradient(180deg, #172134, #0c1424);
      border: 1px solid #2c3958;
      box-shadow: inset 0 0 0 2px #0b101a, inset 0 0 28px #0e1a33aa, 0 10px 24px rgba(0, 0, 0, .30);
      overflow: hidden;
      contain: layout paint size;
      min-height: calc(var(--card-w));
      flex: 1 1 auto;
      display: block;
    }

    /* narrower */
    .zone {
      position: absolute;
      left: 6px; right: 6px; top: 6px; bottom: 6px;
      display: flex;
      gap: 10px;
      flex-wrap: nowrap;
      align-items: center;          /* центрирование по вертикали */
      justify-content: center;      /* по горизонтали центр по умолчанию */
      overflow-x: auto;
      overflow-y: hidden;
      border-radius: 10px;
      clip-path: inset(0 round 10px)
    }

    /* Cards */
    .card {
      width: var(--card-w);
      height: calc(var(--card-w)*0.72);
      border-radius: 10px;
      border: 1px solid #2f3850;
      background: linear-gradient(180deg, #1d2536, #141b2a);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: 0 8px 14px rgba(0, 0, 0, .35), inset 0 0 0 2px #c8d2ee22;
      transition: transform .12s ease-out, box-shadow .12s ease-out
    }

    /* Neon per-letter fills (match main menu chips) */
    .card-F { background: linear-gradient(135deg, #2d5a87, #1a2f49); border-color: #3a5e86; box-shadow: 0 8px 14px rgba(0,0,0,.35), 0 0 0 2px #9cc8ff33 inset, inset 0 0 0 2px #c8d2ee22; }
    .card-I { background: linear-gradient(135deg, #2d7a54, #163d2c); border-color: #2f7d57; box-shadow: 0 8px 14px rgba(0,0,0,.35), 0 0 0 2px #a9ffcf33 inset, inset 0 0 0 2px #c8d2ee22; }
    .card-R { background: linear-gradient(135deg, #9a7542, #3c2a18); border-color: #8c6a3f; box-shadow: 0 8px 14px rgba(0,0,0,.35), 0 0 0 2px #ffd19533 inset, inset 0 0 0 2px #c8d2ee22; }
    .card-S { background: linear-gradient(135deg, #9a4262, #361a28); border-color: #8b3b58; box-shadow: 0 8px 14px rgba(0,0,0,.35), 0 0 0 2px #ff9aa433 inset, inset 0 0 0 2px #c8d2ee22; }
    .card-T { background: linear-gradient(135deg, #6e4d9a, #2a2140); border-color: #65458f; box-shadow: 0 8px 14px rgba(0,0,0,.35), 0 0 0 2px #c6b3ff33 inset, inset 0 0 0 2px #c8d2ee22; }

    /* Forbid badge on F: high contrast (amber) and compact */
    .card-F .badge {
      background: rgba(255, 211, 107, 0.16);
      border-color: rgba(255, 211, 107, 0.55);
      color: #ffd36b;
    }

    .card.hand {
      width: var(--card-w-hand);
      height: var(--card-w-hand)
    }

    .card.clickable {
      cursor: pointer
    }

    .card.clickable:hover {
      box-shadow: 0 10px 16px rgba(0, 0, 0, .4), 0 0 0 2px var(--outline) inset;
      transform: translateY(-2px)
    }

    .L {
      font-size: clamp(32px, 5.8vw, 52px);
      font-weight: 1000;
      letter-spacing: 2px;
      line-height: 1;
      text-shadow: 0 1px 0 #000
    }

    .card.hand .L {
      font-size: calc(0.576 * (clamp(32px, 5.8vw, 52px)));
    }

    .L.F {
      color: #9cc8ff
    }

    .L.I {
      color: #a9ffcf
    }

    .L.R {
      color: #ffd195
    }

    .L.S {
      color: #ff9aa4
    }

    .L.T {
      color: #c6b3ff
    }

    /* Forbid FX as card border */
    .forbidFx {
      border-color: var(--forbid) !important;
      /* only inner glow, no outside overflow */
      box-shadow: 0 0 0 2px #ffd36bbb inset, 0 0 0 3px #ffd36b44 inset;
    }

    .badge {
      position: absolute;
      top: 5px;
      right: 5px;
      background: #0f1422;
      border: 1px solid #2a3244;
      color: #ffd36b;
      padding: 0 calc(var(--card-w) * 0.06);
      font-size: calc(var(--card-w) * 0.14);
      font-weight: 800;
      border-radius: 10px;
      z-index: 5;
      pointer-events: none;
      line-height: 1.15;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .35)
    }

    /* Turn highlight */
    .activeTurn {
      outline: 2px solid var(--ring);
      box-shadow: 0 0 0 6px #3aa1ff14 inset, 0 0 0 2px var(--ring) inset
    }

    /* Discard piles */
    .stackPiles {
      display: grid;
      gap: 10px;
      overflow: hidden
    }

    .pile {
      position: relative;
      display: inline-flex;
      align-items: flex-end;
      gap: 10px;
      flex-wrap: nowrap;
      padding-left: 24px;
      max-width: 100%
    }

    .pile .mini {
      width: 30px;
      height: 42px;
      border-radius: 8px;
      border: 1px solid #2f3850;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: 0 6px 10px rgba(0, 0, 0, .28), inset 0 0 0 2px #c8d2ee22;
      flex: 0 0 auto
    }

    .pile .mini b {
      font-size: 18px;
      line-height: 1;
      text-shadow: 0 1px 0 #000
    }

    /* Discard mini cards per-letter fill to match main cards */
    .mini-F { background: linear-gradient(135deg, #2d5a87, #1a2f49); border-color: #3a5e86; }
    .mini-I { background: linear-gradient(135deg, #2d7a54, #163d2c); border-color: #2f7d57; }
    .mini-R { background: linear-gradient(135deg, #9a7542, #3c2a18); border-color: #8c6a3f; }
    .mini-S { background: linear-gradient(135deg, #9a4262, #361a28); border-color: #8b3b58; }
    .mini-T { background: linear-gradient(135deg, #6e4d9a, #2a2140); border-color: #65458f; }
    .pile .mini b.F { color: #9cc8ff; }
    .pile .mini b.I { color: #a9ffcf; }
    .pile .mini b.R { color: #ffd195; }
    .pile .mini b.S { color: #ff9aa4; }
    .pile .mini b.T { color: #c6b3ff; }

    /* per-letter count badge on mini card */
    .miniCount {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(10,14,24,.9);
      border: 1px solid #2a3244;
      color: #e6eeff;
      font-size: 10px;
      padding: 0 4px;
      border-radius: 999px;
      line-height: 1.1;
      pointer-events: none;
    }

    .pile .mini+.mini {
      margin-left: -14px
    }

    .pile .count {
      position: absolute;
      top: 2px;
      right: 2px;
      background: #0f1422;
      border: 1px solid #2a3244;
      color: #dbe5ff;
      padding: 2px 6px;
      font-size: 12px;
      border-radius: 999px;
      z-index: 3
    }

    /* Space stacks */
    .stack {
      position: relative;
      width: var(--card-w);
      height: calc(var(--card-w) * 0.72);
      flex: 0 0 auto;
      overflow: hidden;
    }
    .stack .card {
      position: absolute;
      left: 0;
      top: 0;
    }
    .stack .card-layer:nth-child(1) { z-index: 1; }
    .stack .card-layer:nth-child(2) { z-index: 2; }
    .stack .card-layer:nth-child(3) { z-index: 3; }
    .stack .card-top { z-index: 4; }
    .stack .countTL {
      position: absolute;
      top: 3px;
      left: 3px;
      background: rgba(15, 20, 34, 0.9);
      border: 1px solid #2a3244;
      color: #e6eeff;
      padding: 0 4px;
      font-size: clamp(9px, calc(var(--card-w) * 0.18), 13px);
      border-radius: 999px;
      z-index: 5;
      pointer-events: none;
      line-height: 1.2;
    }

    /* Hand */
    .handPanel {
      padding: 10px
    }

    .handRow {
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
      align-items: center;
      justify-content: center; /* center the whole hand */
      padding: 4px;
      overflow: hidden;
      scrollbar-width: none
    }

    /* Log */
    .logPanel {
      min-height: 0;
      display: flex;
      flex-direction: column;
      height: auto
    }

    .logHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px
    }

    .log {
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
      background: #0e1524;
      border: 1px solid #25314a;
      border-radius: 10px;
      padding: 10px;
      color: #c6d0ec;
      font-size: 13px;
      line-height: 1.35
    }

    .logPanel.collapsed {
      height: 42px
    }

    .logPanel.collapsed .log {
      display: none
    }

    /* Menu, modals, dice */
    .menu {
      position: fixed;
      inset: 0;
      z-index: 280;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: calc(16px + env(safe-area-inset-top)) 16px calc(16px + env(safe-area-inset-bottom)) 16px;
      background: radial-gradient(1200px 600px at 50% 10%, #1a2440cc, transparent), linear-gradient(180deg, #0e1422f2, #0a0f18f2);
      min-height: 100dvh;
      box-sizing: border-box;
    }

    .menu .cardmenu {
      background: linear-gradient(180deg, #0f1728, #0b1220);
      border: 1px solid #2d3754;
      border-radius: 20px;
      padding: 22px;
      width: min(520px, 92vw);
      box-shadow: 0 28px 56px rgba(0, 0, 0, .55);
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }

    .main-menu {
      padding: clamp(20px, 5vh, 40px) clamp(16px, 4vw, 32px);
      gap: clamp(16px, 3vh, 32px)
    }

    .main-title {
      font-size: clamp(36px, 8vh, 72px);
      font-weight: 900;
      color: #9cc8ff;
      text-shadow: 0 0 30px #9cc8ff66, 0 2px 4px rgba(0,0,0,0.8);
      margin-bottom: clamp(8px, 2vh, 24px);
      letter-spacing: clamp(1px, 0.6vw, 4px)
    }

    .menu .muted {
      color: #acb6cf;
      font-size: 13px;
      margin-bottom: 12px
    }

    .menu .items {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: clamp(12px, 2.5vh, 16px);
      width: 100%;
      margin-bottom: clamp(16px, 3vh, 32px)
    }

    .menu .btn.big {
      font-size: clamp(14px, 2.4vh, 18px);
      font-weight: 700;
      padding: clamp(10px, 2.6vh, 18px) clamp(16px, 4.2vh, 32px);
      width: 100%;
      max-width: 320px;
      border-radius: 16px
    }

    .menu .btn.big.modern {
      background: linear-gradient(135deg, #1a2738, #0e1625);
      border: 1.5px solid #3a4a6a;
      color: #e8f0ff;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3)
    }

    .menu .btn.big.modern:hover {
      background: linear-gradient(135deg, #1f2d42, #12192a);
      border-color: #4a5a84;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4)
    }

    .menu-cards {
      display: flex;
      gap: clamp(10px, 2vh, 16px);
      justify-content: center;
      align-items: center;
      margin-top: clamp(10px, 2vh, 16px)
    }

    .menu-card {
      width: clamp(40px, 9vh, 64px);
      height: clamp(40px, 9vh, 64px);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(20px, 4vh, 32px);
      font-weight: 900;
      position: relative;
      box-shadow: 0 0 0 3px transparent, 0 4px 12px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .card-f {
      background: linear-gradient(135deg, #4a7ba7, #2d5a87);
      color: #9cc8ff;
      box-shadow: 0 0 0 3px #9cc8ff44, 0 4px 12px rgba(0,0,0,0.4)
    }

    .card-i {
      background: linear-gradient(135deg, #4a9a6e, #2d7a54);
      color: #a9ffcf;
      box-shadow: 0 0 0 3px #a9ffcf44, 0 4px 12px rgba(0,0,0,0.4)
    }

    .card-r {
      background: linear-gradient(135deg, #b8935a, #9a7542);
      color: #ffd195;
      box-shadow: 0 0 0 3px #ffd19544, 0 4px 12px rgba(0,0,0,0.4)
    }

    .card-s {
      background: linear-gradient(135deg, #b85a75, #9a4262);
      color: #ff9aa4;
      box-shadow: 0 0 0 3px #ff9aa444, 0 4px 12px rgba(0,0,0,0.4)
    }

    .card-t {
      background: linear-gradient(135deg, #8a6bb8, #6e4d9a);
      color: #c6b3ff;
      box-shadow: 0 0 0 3px #c6b3ff44, 0 4px 12px rgba(0,0,0,0.4)
    }

    @media (hover: hover) {
      .menu-card:hover {
        transform: translateY(-4px) scale(1.05);
        box-shadow: 0 0 0 3px currentColor, 0 8px 24px rgba(0,0,0,0.5);
      }
    }

    /* Активное состояние по тапу (мобайлы) */
    .menu-card.menu-card-active {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 0 0 3px currentColor, 0 8px 24px rgba(0,0,0,0.5);
    }

    .rules-container {
      width: min(800px, 95vw);
      max-height: 90vh;
      display: flex;
      flex-direction: column
    }

    .rules-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid #2d3754
    }

    .rules-header h2 {
      margin: 0;
      color: #dbe5ff;
      font-size: 20px;
      font-weight: 800;
      flex: 1;
      text-align: center
    }

    .rules-lang-btn {
      font-size: 12px;
      padding: 6px 10px;
      min-width: 70px;
      border-radius: 8px;
      margin-left: 16px
    }

    .rules-content {
      flex: 1;
      overflow-y: auto;
      max-height: 60vh;
      padding-right: 8px;
      margin-bottom: 20px
    }

    .rules-text {
      font-size: 14px;
      color: #dfe7ff;
      line-height: 1.6;
      text-align: left
    }

    .rules-footer {
      text-align: center;
      padding-top: 16px;
      border-top: 1px solid #2d3754
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 260;
      backdrop-filter: blur(2px)
    }

    .modal .box {
      background: #10182a;
      border: 1px solid #2a3450;
      border-radius: 14px;
      max-width: 720px;
      width: 100%;
      box-shadow: 0 10px 24px rgba(0, 0, 0, .5)
    }

    .modal .head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid #253254
    }

    .modal .body {
      padding: 12px;
      /* text-align: center */
    }

    .choices {
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .choice {
      padding: 8px 12px;
      border: 1px solid #2a3142;
      border-radius: 10px;
      background: #161b28;
      color: #dbe5ff;
      cursor: pointer
    }

    .choice:hover {
      outline: 2px solid var(--outline)
    }

    .diceOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 240;
      background: rgba(5, 8, 12, .6)
    }

    .diceArea {
      display: flex;
      gap: 40px;
      align-items: center
    }

    .die {
      width: 72px;
      height: 72px;
      position: relative;
      transform-style: preserve-3d;
      transform: rotateX(0) rotateY(0)
    }

    .face {
      position: absolute;
      width: 100%;
      height: 100%;
      background: #e8eefc;
      border-radius: 10px;
      box-shadow: inset 0 0 0 2px #b5c3ea;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      color: #1b2b5a;
      font-size: 28px
    }

    .face:nth-child(1) {
      transform: translateZ(36px)
    }

    .face:nth-child(2) {
      transform: rotateY(90deg) translateZ(36px)
    }

    .face:nth-child(3) {
      transform: rotateY(180deg) translateZ(36px)
    }

    .face:nth-child(4) {
      transform: rotateY(-90deg) translateZ(36px)
    }

    .face:nth-child(5) {
      transform: rotateX(90deg) translateZ(36px)
    }

    .face:nth-child(6) {
      transform: rotateX(-90deg) translateZ(36px)
    }

    .diceTxt {
      color: #dbe5ff;
      font-weight: 800;
      text-shadow: 0 1px 0 #000
    }

    .handRow::-webkit-scrollbar {
      display: none
    }

    ::-webkit-scrollbar {
      height: 8px;
      width: 8px
    }

    ::-webkit-scrollbar-track {
      background: #0b1019
    }

    ::-webkit-scrollbar-thumb {
      background: #22334a;
      border-radius: 8px
    }

    /* ===== Mobile-first ===== */
    @media (max-width: 900px) {
      :root {
        --zone-k: 1.00;
        --zone-c: 14px;
      }

      :root {
        --zone-k: 0.78;
        --zone-c: 20px;
        --card-w: clamp(34px, 8.8vw, 62px);
        --gap: 8px;
        --page-max: 980px;
      }

      h1 {
        font-size: 15px
      }

      .pill {
        padding: 4px 6px;
        font-size: 11px
      }

      .title {
        font-size: 12px
      }

      .L {
        font-size: clamp(14px, 4.9vw, 18px)
      }

      .boardGrid {
        inset: 10px 0 0 0;
        gap: 8px;
      }

      .boardFlat {
        min-height: calc(var(--card-w))
      }

      /* mobile fit */
      .zone {
        inset: 8px
      }

      .logPanel {
        height: auto
      }

      .controls .btn {
        display: none
      }

      #hamburger {
        display: block
      }

      /* Main menu mobile adaptations */
      .main-title {
        font-size: 48px;
        margin-bottom: 16px;
        letter-spacing: 2px
      }

      .main-menu {
        padding: 24px 20px
      }

      .menu-cards {
        gap: 12px;
        margin-top: 12px
      }

      .menu-card {
        width: 48px;
        height: 48px;
        font-size: 24px
      }

      .menu .btn.big {
        font-size: 16px;
        padding: 14px 24px
      }
    }

    @media (max-width: 600px) {
      :root {
        --zone-k: 1.04;
        --zone-c: 12px;
      }

      :root {
        --zone-k: 0.78;
        --zone-c: 18px;
        --card-w: clamp(28px, 7.6vw, 52px);
        --gap: 6px;
      }

      h1 {
        font-size: 13px
      }

      .pill {
        padding: 3px 5px;
        font-size: 10px
      }

      .title {
        font-size: 12px
      }

      .L {
        font-size: clamp(15px, 4.4vw, 22px)
      }

      .boardGrid {
        inset: 6px 0 0 0;
        gap: 6px;
      }

      .boardFlat {
        min-height: calc(var(--card-w) * 0.92)
      }

      .zone {
        left: 6px; right: 6px; top: 6px; bottom: 6px;
        align-items: center;
        justify-content: center;
      }

      /* уменьшить толщину обводки карт на маленьких экранах */
      .card { border-width: 1px; box-shadow: 0 6px 10px rgba(0,0,0,.28), inset 0 0 0 1px #c8d2ee22; }
      .pile .mini { border-width: 1px; box-shadow: 0 6px 10px rgba(0,0,0,.28); }

      /* уменьшить толщину обводки карт на маленьких экранах */
      .card { border-width: 1px; box-shadow: 0 6px 10px rgba(0,0,0,.28), inset 0 0 0 1px #c8d2ee22; }
      .pile .mini { border-width: 1px; box-shadow: 0 6px 10px rgba(0,0,0,.28); }

      /* сделать буквы визуально меньше относительно карты в зоне */
      /* Уменьшаем букву и добавляем внутренние отступы карты на мобилках, чтобы буква не занимала всю карту */
      .zone .card { padding: calc(var(--card-w) * 0.06); }
      .zone .card .L { font-size: calc(var(--card-w) * 0.26); }
      .zone .card.hand { padding: calc(var(--card-w) * 0.05); }
      .zone .card.hand .L { font-size: calc(var(--card-w) * 0.22); }

      .logPanel {
        height: auto
      }

      /* smaller discard badges on very small screens */
      .pile .mini .miniCount {
        font-size: 8px;
        padding: 0 3px;
        top: 1px;
        right: 1px;
      }

      /* smaller forbid badge on F on small screens */
      .card .badge {
        font-size: 10px;
        padding: 0 4px;
        top: 3px;
        right: 3px;
      }
    }

    @media (min-width: 700px) and (max-width: 1180px) {
      :root {
        --zone-k: 0.86;
        --zone-c: 18px;
      }

      :root {
        --zone-k: 0.78;
        --zone-c: 20px;
        --card-w: clamp(88px, 8.6vw, 140px);
      }

      .L {
        font-size: clamp(30px, 5.4vw, 58px);
      }

      .boardFlat {
        height: calc(var(--card-w));
      }

      .handRow {
        gap: 10px;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="center">
        <div class="titlebar">
          <h1 id="titleTxt">F!RST</h1>
          <span class="pill"><span id="turnKey">Turn</span>: <b id="turnLbl">—</b></span>
          <span class="pill"><span id="yourHandKey">Your hand</span>: <b id="youHandCount">0</b>/7</span>
          <span class="pill"><span id="aiHandKey">AI hand</span>: <b id="aiHandCount">0</b></span>
          <span class="pill" id="timerPill">00:00</span>
        </div>
        <div class="controls">
          <button class="btn" id="langBtn" title="Language">🇬🇧 EN</button>
          <button class="btn" id="toMenuBtn">Menu</button>
          <button class="btn" id="helpBtn">Rules</button>
          <button class="btn" id="restartBtn">New Game</button>
          <button class="btn" id="hamburger">☰</button>
        </div>
      </div>
      <div class="quickMenu" id="quickMenu">
        <button class="btn" id="qmLang">🇬🇧 EN</button>
        <button class="btn" id="qmMenu">Menu</button>
        <button class="btn" id="qmHelp">Rules</button>
        <button class="btn" id="qmNew">New Game</button>
      </div>
    </header>

    <div class="boardShell">
      <div class="center" style="height:100%">
        <div id="boardGrid" class="boardGrid">
          <div class="leftCol">
            <div id="panelAiSpace" class="panel">
              <div class="title"><span id="aiSpaceTitle">SPACE — AI</span><span class="chip" id="aiDeckInfo">Deck: 50</span></div>
              <div class="boardFlat">
                <div id="aiSpace" class="zone"></div>
              </div>
            </div>
            <div id="panelYouSpace" class="panel">
              <div class="title"><span id="youSpaceTitle">SPACE — You</span><span class="chip" id="youDeckInfo">Deck: 50</span></div>
              <div class="boardFlat">
                <div id="youSpace" class="zone"></div>
              </div>
            </div>
            <div class="panel handPanel">
              <div class="title" id="yourHandTitle">Your hand <span class="note" id="handNote" style="display:none">(tap
                  a card to play; turn ends automatically)</span></div>
              <div id="youHand" class="handRow"></div>
            </div>
          </div>
          <div class="rightCol">
            <div class="panel" id="panelAiDiscard">
              <div class="title" id="aiDiscardTitle">DISCARD — AI</div>
              <div id="aiDiscard" class="stackPiles" style="flex:1 1 auto"></div>
            </div>
            <div class="panel" id="panelYouDiscard">
              <div class="title" id="youDiscardTitle">DISCARD — You</div>
              <div id="youDiscard" class="stackPiles" style="flex:1 1 auto"></div>
            </div>
            <div class="panel logPanel" id="logPanel" style="flex:1 1 auto">
              <div class="logHeader">
                <div class="title" id="logTitle" style="margin:0">Game log</div>
                <button id="toggleLog" class="btn" style="padding:4px 10px">Hide</button>
              </div>
              <div id="log" class="log" style="flex:1 1 auto"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Menus and modals -->
  <div id="menu" class="menu" style="display:flex">
    <div class="cardmenu main-menu">
      <div class="main-title">F!RST</div>
      <div class="items">
        <button class="btn big modern" id="menuNewGame">New Game</button>
        <button class="btn big modern" id="menuRules">Rules</button>
      </div>
      <div class="menu-cards">
        <div class="menu-card card-f">F</div>
        <div class="menu-card card-i">I</div>
        <div class="menu-card card-r">R</div>
        <div class="menu-card card-s">S</div>
        <div class="menu-card card-t">T</div>
      </div>
    </div>
  </div>

  <div id="rulesMenu" class="menu" style="display:none">
    <div class="cardmenu rules-container">
      <div class="rules-header">
        <h2 id="rulesMenuTitle">F!RST — Rules & Cards</h2>
        <button class="btn rules-lang-btn" id="rulesLangBtn">🇬🇧 EN</button>
      </div>
      <div class="rules-content">
        <div class="rules-text" id="rulesMenuBody"></div>
      </div>
      <div class="rules-footer">
        <button class="btn big" id="backToMenu">Back to Menu</button>
      </div>
    </div>
  </div>

  <div id="diceOverlay" class="diceOverlay">
    <div class="diceArea">
      <div>
        <div class="diceTxt" style="margin-bottom:6px;text-align:center" id="youTxt">You</div>
        <div id="dieYou" class="die">
          <div class="face">1</div>
          <div class="face">2</div>
          <div class="face">3</div>
          <div class="face">4</div>
          <div class="face">5</div>
          <div class="face">6</div>
        </div>
      </div>
      <div>
        <div class="diceTxt" style="margin-bottom:6px;text-align:center" id="aiTxt">AI</div>
        <div id="dieAI" class="die">
          <div class="face">1</div>
          <div class="face">2</div>
          <div class="face">3</div>
          <div class="face">4</div>
          <div class="face">5</div>
          <div class="face">6</div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="choiceModal">
    <div class="box">
      <div class="head">
        <div id="choiceTitle">Choose</div>
        <div></div>
      </div>
      <div class="body">
        <div id="choiceArea" class="choices"></div>
      </div>
    </div>
  </div>

  <div class="modal" id="helpModal">
    <div class="box">
      <div class="head">
        <div style="font-weight:800" id="rulesTitle">F!RST — rules & cards</div><button class="btn"
          id="closeHelp">Close</button>
      </div>
      <div class="body">
        <div class="note" style="font-size:13px;color:#dfe7ff" id="rulesBody"></div>
      </div>
    </div>
  </div>

  <div class="modal" id="winModal">
    <div class="box">
      <div class="head" style="justify-content:center;gap:10px">
        <div style="font-weight:800" id="gameOverKey">Game Over</div>
      </div>
      <div class="body">
        <h3 id="winTitle">Victory!</h3>
        <div id="winMsg" class="msg">You completed a combo.</div>
        <div class="okbar" style="display:flex;justify-content:center;gap:8px;margin-top:8px">
          <button class="btn" id="winNew">New Game</button>
          <button class="btn" id="winMenu">Menu</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===== i18n ===== */
    const I18N = {
      en: {
        title: "F!RST", turnKey: "Turn", yourHandKey: "Your hand", aiHandKey: "AI hand",
        btnMenu: "Menu", btnNew: "New Game", welcome: "Welcome to F!RST", menuNew: "New Game", menuRules: "Rules",
        rulesMenuTitle: "F!RST — Rules & Cards", backToMenu: "Back to Menu",
        you: "You", ai: "AI", spaceAI: "SPACE — AI", spaceYou: "SPACE — You", discardAI: "DISCARD — AI", discardYou: "DISCARD — You",
        logTitle: "Game log", handTitle: "Your hand", handNote: "(tap a card to play; turn ends automatically)",
        rulesTitle: "F!RST — rules & cards", gameOver: "Game Over",
        deckLabel: (n) => `Deck: ${n}`,
        rulesBody: `<strong>GAME OBJECTIVE:</strong><br/>
Assemble the sequence F-I-R-S-T or 5 cards of the same type in your SPACE area to win.<br/><br/>

<strong>SETUP:</strong><br/>
• Each player draws 5 cards to hand<br/>
• Dice roll determines who goes first<br/>
• First player does NOT draw a card on their first turn<br/><br/>

<strong>PLAYER TURN:</strong><br/>
1. Draw 1 card from deck (except first turn)<br/>
2. Play 1 card from hand to SPACE area<br/>
3. Execute card effect<br/>
4. Turn passes to opponent<br/><br/>

<strong>CARDS AND EFFECTS:</strong><br/>
<span style="color:#9cc8ff"><strong>F (FORBID)</strong></span> — Choose a letter. If opponent tries to play that letter, it goes to their DISCARD instead of SPACE<br/>
<span style="color:#a9ffcf"><strong>I (INCREASE)</strong></span> — Draw +1 card from deck<br/>
<span style="color:#ffd195"><strong>R (RECOVER)</strong></span> — Choose a card from your DISCARD and return it to hand<br/>
<span style="color:#ff9aa4"><strong>S (STEAL)</strong></span> — Choose a card from opponent's SPACE and move it to their DISCARD<br/>
<span style="color:#c6b3ff"><strong>T (TRAP)</strong></span> — Next turn, opponent must discard 1 card from hand<br/><br/>

<strong>IMPORTANT RULES:</strong><br/>
• Maximum 7 cards in hand. Excess cards are automatically discarded<br/>
• If deck is empty when required to draw — you lose<br/>
• Forbidden cards (F effect) go to DISCARD, not SPACE<br/>
• Traps (T effect) trigger at start of opponent's next turn`,
        choose: "Choose", pickForbid: "Choose a letter to forbid", pickRecover: "Recover: choose a letter from your DISCARD",
        pickSteal: "Steal: choose a card from opponent SPACE", pickTrapDiscard: "Trap (T): choose a card to discard",
        drewYou: "You drew a card.", drewAI: "AI drew a card.",
        overflowYou: (c) => `Your hand overflow: ${c} → DISCARD.`, overflowAI: (c) => `AI's hand overflow: ${c} → DISCARD.`,
        playedYou: (c) => `You played ${c}.`, playedAI: (c) => `AI played ${c}.`,
        recoverYou: (c) => `You recovered ${c} to hand.`, recoverAI: "AI recovered a card to hand.",
        stealYou: (c) => `You moved opponent ${c} to DISCARD.`, stealAI: (c) => `AI stole your ${c} to your DISCARD.`,
        tYou: "You used T: AI discarded 1 card.", tAI: "AI used T: you must discard 1 card.",
        winVictory: "🎉 Victory!", winDefeat: "😞 Defeat", winDraw: "Draw",
        loseByFirst: "Opponent assembled F I R S T.",
        loseByFive: "Opponent made 5 of a kind.",
        loseByDeck: "Your deck ran out on a required draw.",
        winByFirst: "You assembled F I R S T.",
        winByFive: "You made 5 of a kind.",
        winByDeck: "AI had no cards to draw.",
        showLog: "Show", hideLog: "Hide"
      },
      ru: {
        title: "F!RST", turnKey: "Ход", yourHandKey: "Твоя рука", aiHandKey: "Рука ИИ",
        btnMenu: "Меню", btnNew: "Новая игра", welcome: "Добро пожаловать в F!RST", menuNew: "Новая игра", menuRules: "Правила",
        rulesMenuTitle: "F!RST — Правила и карты", backToMenu: "Назад в меню",
        you: "Ты", ai: "ИИ", spaceAI: "SPACE — ИИ", spaceYou: "SPACE — Ты", discardAI: "DISCARD — ИИ", discardYou: "DISCARD — Ты",
        logTitle: "Журнал боя", handTitle: "Твоя рука", handNote: "(нажми на карту, чтобы сыграть; ход завершится сам)",
        rulesTitle: "F!RST — правила и карты", gameOver: "Конец игры",
        deckLabel: (n) => `Колода: ${n}`,
        rulesBody: `<strong>ЦЕЛЬ ИГРЫ:</strong><br/>
Соберите последовательность F-I-R-S-T или 5 одинаковых карт в области SPACE для победы.<br/><br/>

<strong>ПОДГОТОВКА:</strong><br/>
• Каждый игрок получает 5 карт в руку<br/>
• Бросок кубиков определяет, кто ходит первым<br/>
• Первый игрок НЕ берет карту в свой первый ход<br/><br/>

<strong>ХОД ИГРОКА:</strong><br/>
1. Взять 1 карту из колоды (кроме первого хода)<br/>
2. Сыграть 1 карту из руки в область SPACE<br/>
3. Выполнить эффект карты<br/>
4. Ход переходит к сопернику<br/><br/>

<strong>КАРТЫ И ИХ ЭФФЕКТЫ:</strong><br/>
<span style="color:#9cc8ff"><strong>F (FORBID)</strong></span> — Выберите букву. Если противник попытается сыграть эту букву, она отправится в его DISCARD вместо SPACE<br/>
<span style="color:#a9ffcf"><strong>I (INCREASE)</strong></span> — Возьмите +1 карту из колоды<br/>
<span style="color:#ffd195"><strong>R (RECOVER)</strong></span> — Выберите карту из своего DISCARD и верните в руку<br/>
<span style="color:#ff9aa4"><strong>S (STEAL)</strong></span> — Выберите карту из SPACE противника и переместите в его DISCARD<br/>
<span style="color:#c6b3ff"><strong>T (TRAP)</strong></span> — В следующий ход противник должен сбросить 1 карту из руки<br/><br/>

<strong>ВАЖНЫЕ ПРАВИЛА:</strong><br/>
• Максимум 7 карт в руке. Лишние карты автоматически сбрасываются<br/>
• Если колода закончилась при необходимом взятии карты — поражение<br/>
• Запрещенные карты (эффект F) идут в DISCARD, а не в SPACE<br/>
• Ловушки (эффект T) срабатывают в начале следующего хода противника`,
        choose: "Выбор", pickForbid: "Выбери букву для блока", pickRecover: "Recover: выбери букву из DISCARD",
        pickSteal: "Укажи карту на столе противника", pickTrapDiscard: "Ловушка (T): выбери карту для сброса",
        drewYou: "Ты взял карту.", drewAI: "ИИ взял карту.",
        overflowYou: (c) => `Переполнение руки: ${c} → DISCARD.`, overflowAI: (c) => `Переполнение руки ИИ: ${c} → DISCARD.`,
        playedYou: (c) => `Ты сыграл ${c}.`, playedAI: (c) => `ИИ сыграл ${c}.`,
        recoverYou: (c) => `Ты вернул ${c} в руку.`, recoverAI: "ИИ вернул карту в руку.",
        stealYou: (c) => `Ты отправил карту противника ${c} в DISCARD.`, stealAI: (c) => `ИИ отправил твою ${c} в DISCARD.`,
        tYou: "Ты применил T: ИИ сбросил 1 карту.", tAI: "ИИ применил T: сбрось 1 карту.",
        winVictory: "🎉 Победа!", winDefeat: "😞 Поражение", winDraw: "Ничья",
        loseByFirst: "Противник собрал F I R S T.",
        loseByFive: "Противник собрал 5 одинаковых карт.",
        loseByDeck: "В колоде не осталось карт при доборе.",
        winByFirst: "Ты собрал F I R S T.",
        winByFive: "Ты собрал 5 одинаковых карт.",
        winByDeck: "У ИИ закончились карты для добора.",
        showLog: "Показать", hideLog: "Скрыть"
      }
    };
    let LANG = 'en';
    function tt(key, ...args) { const v = I18N[LANG][key]; return (typeof v === 'function') ? v(...args) : v; }
    function applyTexts() {
      document.getElementById('titleTxt').textContent = tt('title');
      document.getElementById('turnKey').textContent = tt('turnKey');
      document.getElementById('yourHandKey').textContent = tt('yourHandKey');
      document.getElementById('aiHandKey').textContent = tt('aiHandKey');
      document.getElementById('toMenuBtn').textContent = tt('btnMenu');
      document.getElementById('restartBtn').textContent = tt('btnNew');
      document.getElementById('aiSpaceTitle').textContent = tt('spaceAI');
      document.getElementById('youSpaceTitle').textContent = tt('spaceYou');
      document.getElementById('aiDiscardTitle').textContent = tt('discardAI');
      document.getElementById('youDiscardTitle').textContent = tt('discardYou');
      document.getElementById('logTitle').textContent = tt('logTitle');
      document.getElementById('yourHandTitle').firstChild.textContent = tt('handTitle') + ' ';
      document.getElementById('handNote').textContent = tt('handNote');
      document.getElementById('menuNewGame').textContent = tt('menuNew');
      document.getElementById('menuRules').textContent = tt('menuRules');
      document.getElementById('rulesMenuTitle').textContent = tt('rulesMenuTitle');
      document.getElementById('backToMenu').textContent = tt('backToMenu');
      document.getElementById('rulesMenuBody').innerHTML = tt('rulesBody');
      document.getElementById('youTxt').textContent = tt('you');
      document.getElementById('aiTxt').textContent = tt('ai');
      document.getElementById('rulesTitle').textContent = tt('rulesTitle');
      document.getElementById('rulesBody').innerHTML = tt('rulesBody');
      document.getElementById('gameOverKey').textContent = tt('gameOver');
      document.getElementById('toggleLog').textContent = document.getElementById('logPanel').classList.contains('collapsed') ? tt('showLog') : tt('hideLog');
      const langTxt = LANG === 'en' ? '🇬🇧 EN' : '🇷🇺 RU';
      document.getElementById('langBtn').textContent = langTxt;
      document.getElementById('qmLang').textContent = langTxt;
      const rulesLangBtn = document.getElementById('rulesLangBtn');
      if (rulesLangBtn) rulesLangBtn.textContent = langTxt;
      document.getElementById('qmMenu').textContent = tt('btnMenu');
      document.getElementById('qmHelp').textContent = 'Rules';
      document.getElementById('qmNew').textContent = tt('btnNew');
        // Update deck info labels with localization
        const youDeckInfo = document.getElementById('youDeckInfo');
        const aiDeckInfo = document.getElementById('aiDeckInfo');
        if (youDeckInfo) youDeckInfo.textContent = tt('deckLabel', (G && G.you ? G.you.deck.length : 50));
        if (aiDeckInfo) aiDeckInfo.textContent = tt('deckLabel', (G && G.ai ? G.ai.deck.length : 50));
    }

    /* Card helper */
    function cardEl(letter, opts = {}) {
      const d = document.createElement('div');
      d.className = 'card' + (opts.hand ? ' hand' : '') + (opts.clickable ? ' clickable' : '');
      const span = document.createElement('div'); span.className = 'L ' + letter; span.textContent = letter; d.appendChild(span);
      if (opts.clickable && opts.onClick) d.addEventListener('click', opts.onClick);
      return d;
    }

    /* ===== Game state and logic ===== */
    const TYPES = ['F', 'I', 'R', 'S', 'T'];
    let G = null, timerId = null, elapsed = 0;
    function sideState() { return { deck: buildDeck(), hand: [], space: [], discard: [] }; }
    function buildDeck() { const d = []; for (let i = 0; i < 10; i++) for (const t of TYPES) d.push(t); return d; }
    function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; }

    function newGame() {
      document.getElementById('log').innerHTML = '';
      G = {
        turn: null, firstPlayer: null, firstTurnDone: false,
        you: sideState(), ai: sideState(),
        traps: { forbidYou: null, forbidAI: null, tNextYou: 0, tNextAI: 0 },
        over: false
      };
      shuffle(G.you.deck); shuffle(G.ai.deck);
      draw('you', 5); draw('ai', 5);
      startTimer(true);
      openDiceAndDecideFirstPlayer();
      render();
    }

    function setHUD() {
      document.getElementById('youHandCount').textContent = G.you.hand.length;
      document.getElementById('aiHandCount').textContent = G.ai.hand.length;
      document.getElementById('turnLbl').textContent = G.over ? tt('gameOver') : (G.turn === 'you' ? tt('you') : tt('ai'));
      document.getElementById('timerPill').textContent = formatElapsed(elapsed);
        // Deck counters in panel titles
        const youDeckInfo = document.getElementById('youDeckInfo');
        const aiDeckInfo = document.getElementById('aiDeckInfo');
        if (youDeckInfo) youDeckInfo.textContent = tt('deckLabel', G.you.deck.length);
        if (aiDeckInfo) aiDeckInfo.textContent = tt('deckLabel', G.ai.deck.length);
    }

    function render() {
      setHUD();
      updateTurnHighlight();
      computeAdaptiveCardWidth();


      const aiS = document.getElementById('aiSpace'); aiS.innerHTML = '';
      renderStacks(G.ai.space, aiS);
      const youS = document.getElementById('youSpace'); youS.innerHTML = '';
      renderStacks(G.you.space, youS);
      const hand = document.getElementById('youHand'); hand.innerHTML = '';
      G.you.hand.forEach((c, i) => {
        const el = cardEl(c, { hand: true, clickable: G.turn === 'you' && !G.over, onClick: () => playFromHand(i) });
        el.classList.add('card-' + c);
        el.style.transform = 'scale(0.92)';
        hand.appendChild(el);
      });
      renderDiscard('aiDiscard', G.ai.discard);
      renderDiscard('youDiscard', G.you.discard);
      updateForbidFX();
      fitHandToSeven();
      fitMobileScale();
    }

    // Render letter stacks as a single card + counter (from 2nd card)
    function renderStacks(lettersArr, container) {
      const groups = { F: [], I: [], R: [], S: [], T: [] };
      lettersArr.forEach(l => { if (groups[l]) groups[l].push(l); });
      const order = ['F', 'I', 'R', 'S', 'T'];
      order.forEach(l => {
        const cnt = groups[l].length; if (cnt === 0) return;
        const stack = document.createElement('div');
        stack.className = 'stack';
        // Single card
        const topCard = cardEl(l);
        topCard.classList.add('card-' + l, 'card-top');
        stack.appendChild(topCard);
        // Counter from 2 and above
        if (cnt >= 2) {
          const b = document.createElement('div'); b.className = 'countTL'; b.textContent = '×' + cnt; stack.appendChild(b);
        }
        container.appendChild(stack);
      });
    }

    function updateForbidFX() {
      document.querySelectorAll('.forbidFx').forEach(el => el.classList.remove('forbidFx'));
      document.querySelectorAll('.badge').forEach(el => el.remove());
      if (G.traps.forbidAI) {
        // Forbid for AI: highlight player's top F stack top card and show badge letter
        const zone = document.getElementById('youSpace');
        if (zone) {
          const stacks = Array.from(zone.querySelectorAll('.stack'));
          for (let i = stacks.length - 1; i >= 0; i--) {
      const top = stacks[i].querySelector('.card-top .L');
            if (top && top.textContent === 'F') {
              const topCard = stacks[i].querySelector('.card-top');
              if (topCard) {
                topCard.classList.add('forbidFx');
                topCard.classList.add('card-F');
                const b = document.createElement('div'); b.className = 'badge'; b.textContent = G.traps.forbidAI; topCard.appendChild(b);
              }
              break;
            }
          }
        }
      }
      if (G.traps.forbidYou) {
        // Forbid for player: highlight AI's top F stack (no badge text shown to AI)
        const zone = document.getElementById('aiSpace');
        if (zone) {
          const stacks = Array.from(zone.querySelectorAll('.stack'));
          for (let i = stacks.length - 1; i >= 0; i--) {
            const top = stacks[i].querySelector('.card-top .L');
            if (top && top.textContent === 'F') {
              const topCard = stacks[i].querySelector('.card-top');
              if (topCard) topCard.classList.add('forbidFx');
              break;
            }
          }
        }
      }
    }
    function lastIndexOf(arr, val) { for (let i = arr.length - 1; i >= 0; i--) { if (arr[i] === val) return i; } return -1; }

    function renderDiscard(containerId, discardArr) {
      const box = document.getElementById(containerId); box.innerHTML = '';
      const counts = { F: 0, I: 0, R: 0, S: 0, T: 0 }; discardArr.forEach(x => counts[x]++);
      const pile = document.createElement('div'); pile.className = 'pile';
      TYPES.forEach(t => {
        if (counts[t] === 0) return;
        const m = document.createElement('div'); m.className = 'mini mini-' + t;
        const b = document.createElement('b'); b.textContent = t; b.className = t; b.style.color = letterColor(t);
        m.appendChild(b);
        const c = document.createElement('div'); c.className = 'miniCount'; c.textContent = counts[t]; m.appendChild(c);
        pile.appendChild(m);
      });
      const cnt = document.createElement('div'); cnt.className = 'count'; cnt.textContent = discardArr.length;
      pile.appendChild(cnt); box.appendChild(pile);
    }
    function letterColor(l) { return l === 'F' ? '#9cc8ff' : l === 'I' ? '#a9ffcf' : l === 'R' ? '#ffd195' : l === 'S' ? '#ff9aa4' : '#c6b3ff'; }

    function logAdd(s) { const el = document.getElementById('log'); const div = document.createElement('div'); div.textContent = s; el.appendChild(div); el.scrollTop = el.scrollHeight; }

    /* ====== Timer ====== */
    function startTimer(reset) {
      if (reset) { elapsed = 0; }
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => { elapsed++; const p = document.getElementById('timerPill'); if (p) p.textContent = formatElapsed(elapsed); }, 1000);
    }
    function formatElapsed(sec) { const m = Math.floor(sec / 60).toString().padStart(2, '0'); const s = (sec % 60).toString().padStart(2, '0'); return `${m}:${s}`; }

    /* ===== Flow ===== */
    function draw(side, n) {
      const S = (side === 'you') ? G.you : G.ai;
      for (let i = 0; i < n; i++) {
        if (S.deck.length === 0) { defeat(side, 'deck'); return; }
        const c = S.deck.pop(); S.hand.push(c);
        logAdd(side === 'you' ? tt('drewYou') : tt('drewAI'));
        enforceHandLimit(side); if (G.over) return;
      }
    }
    function enforceHandLimit(side) {
      const S = side === 'you' ? G.you : G.ai;
      while (S.hand.length > 7) {
        const overflow = S.hand.pop(); S.discard.push(overflow);
        logAdd(side === 'you' ? tt('overflowYou', overflow) : tt('overflowAI', overflow));
      }
      render();
    }

    function updateTurnHighlight() {
      const youP = document.getElementById('panelYouSpace');
      const aiP = document.getElementById('panelAiSpace');
      youP.classList.toggle('activeTurn', G.turn === 'you' && !G.over);
      aiP.classList.toggle('activeTurn', G.turn === 'ai' && !G.over);
    }

    function startTurn() {
      if (G.over) return;
      const side = G.turn;
      const skip = (!G.firstTurnDone && G.turn === G.firstPlayer);
      if (!skip) { draw(side, 1); if (G.over) return; }
      if (!G.firstTurnDone) G.firstTurnDone = true;

      if (side === 'you' && G.traps.tNextYou > 0) {
        if (G.you.hand.length > 0) {
          chooseIndex(tt('pickTrapDiscard'), G.you.hand, (idx) => {
            const dumped = G.you.hand.splice(idx, 1)[0];
            G.you.discard.push(dumped);
            animateFromSpaceOrHand('you', 'hand', idx, document.getElementById('youDiscard'));
            logAdd("Trap: you discarded a card.");
            G.traps.tNextYou = 0; render();
            // Do NOT end the turn: after discarding, you still take your turn
          });
          return;
        } else G.traps.tNextYou = 0;
      }
      if (side === 'ai' && G.traps.tNextAI > 0) {
        if (G.ai.hand.length > 0) {
          const dumpedIdx = Math.floor(Math.random() * G.ai.hand.length);
          const dumped = G.ai.hand.splice(dumpedIdx, 1)[0];
          G.ai.discard.push(dumped);
          animateFromSpaceOrHand('ai', 'hand', dumpedIdx, document.getElementById('aiDiscard'));
          logAdd("Trap: AI discarded a card.");
          render();
        }
        G.traps.tNextAI = 0;
        // After discarding due to trap, AI still takes its regular turn
      }

      render();
      if (side === 'ai') { setTimeout(aiPlay, 800 + Math.random() * 600); }
    }

    function endTurn() { if (G.over) return; G.turn = (G.turn === 'you') ? 'ai' : 'you'; render(); setTimeout(startTurn, 380); }

    function defeat(side, reason) {
      if (G.over) return; G.over = true;
      const isYouLose = (side === 'you');
      document.getElementById('winTitle').textContent = isYouLose ? tt('winDefeat') : tt('winVictory');
      let msg = '';
      if (reason === 'first') msg = isYouLose ? tt('loseByFirst') : tt('winByFirst');
      else if (reason === 'five') msg = isYouLose ? tt('loseByFive') : tt('winByFive');
      else if (reason === 'deck') msg = isYouLose ? tt('loseByDeck') : tt('winByDeck');
      else msg = isYouLose ? tt('winDefeat') : tt('winVictory');
      document.getElementById('winMsg').textContent = msg;
      document.getElementById('winModal').style.display = 'flex';
    }

    function checkWin() {
      // Count helper ensures robust checks even with UI stacking
      const buildCounts = (arr) => arr.reduce((m, x) => { m[x] = (m[x] || 0) + 1; return m; }, { F:0,I:0,R:0,S:0,T:0 });
      const youC = buildCounts(G.you.space);
      const aiC = buildCounts(G.ai.space);
      const hasAllCounts = (c) => TYPES.every(t => (c[t] || 0) >= 1);
      const fiveOfAny = (c) => TYPES.some(t => (c[t] || 0) >= 5);
      if (hasAllCounts(youC)) { defeat('ai', 'first'); return true; }
      if (fiveOfAny(youC)) { defeat('ai', 'five'); return true; }
      if (hasAllCounts(aiC)) { defeat('you', 'first'); return true; }
      if (fiveOfAny(aiC)) { defeat('you', 'five'); return true; }
      return false;
    }

    function playFromHand(index) {
      if (G.over || G.turn !== 'you') return;
      const letter = G.you.hand[index]; if (!letter) return;
      if (G.traps.forbidYou === letter) {
        G.traps.forbidYou = null;
        const handEl = pickHandCardEl(index);
        G.you.hand.splice(index, 1);
        animateForbidden(handEl, document.getElementById('youSpace'), document.getElementById('youDiscard'), letter);
        logAdd(`Forbid triggered: your ${letter} went to DISCARD.`);
        render(); if (!checkWin()) setTimeout(endTurn, 650); return;
      }
      const src = pickHandCardEl(index);
      G.you.hand.splice(index, 1); G.you.space.push(letter);
      animateFly(src, document.getElementById('youSpace'));
      logAdd(`You played ${letter}.`); render();
      resolveEffect('you', letter, () => { if (!checkWin()) endTurn(); });
    }

    function resolveEffect(side, letter, done) {
      if (letter === 'F') {
        chooseType(tt('pickForbid'), TYPES, (tChosen) => {
          if (side === 'you') { G.traps.forbidAI = tChosen; logAdd("You forbade a letter for AI."); }
          else { G.traps.forbidYou = tChosen; logAdd("AI forbade a letter for you."); }
          render(); done();
        });
        return;
      }
      if (letter === 'I') { draw(side, 1); done(); return; }
      if (letter === 'R') {
        const S = side === 'you' ? G.you : G.ai;
        if (S.discard.length === 0) { done(); return; }
        chooseType(tt('pickRecover'), uniqueLetters(S.discard), (pick) => {
          const idx = S.discard.lastIndexOf(pick);
          if (idx >= 0) {
            const c = S.discard.splice(idx, 1)[0];
            S.hand.push(c);
            animateFromDiscardTo(side, 'hand', c);
            logAdd(side === 'you' ? tt('recoverYou', c) : tt('recoverAI')); enforceHandLimit(side);
          }
          render(); done();
        });
        return;
      }
      if (letter === 'S') {
        const O = side === 'you' ? G.ai : G.you;
        if (O.space.length === 0) { done(); return; }
        chooseIndex(tt('pickSteal'), O.space, (i) => {
          animateFromSpaceOrHand(side === 'you' ? 'ai' : 'you', 'space', i, side === 'you' ? document.getElementById('aiDiscard') : document.getElementById('youDiscard'));
          const removed = O.space.splice(i, 1)[0]; O.discard.push(removed);
          logAdd(side === 'you' ? `You moved opponent ${removed} to DISCARD.` : `AI stole your ${removed} to your DISCARD.`);
          render(); done();
        });
        return;
      }
      if (letter === 'T') {
        // Immediate discard from opponent, turn passes to opponent after done()
        if (side === 'you') {
          if (G.ai.hand.length > 0) {
            const i = Math.floor(Math.random() * G.ai.hand.length);
            const dumped = G.ai.hand.splice(i, 1)[0];
            G.ai.discard.push(dumped);
            animateFromSpaceOrHand('ai', 'hand', i, document.getElementById('aiDiscard'));
          }
          logAdd(tt('tYou'));
        } else {
          if (G.you.hand.length > 0) {
            chooseIndex(tt('pickTrapDiscard'), G.you.hand, (idx) => {
              const dumped = G.you.hand.splice(idx, 1)[0];
              G.you.discard.push(dumped);
              animateFromSpaceOrHand('you', 'hand', idx, document.getElementById('youDiscard'));
              logAdd(tt('tAI'));
              render(); done();
            });
            return;
          } else {
            logAdd(tt('tAI'));
          }
        }
        render(); done(); return;
      }
      done();
    }

    function uniqueLetters(arr) { return Array.from(new Set(arr)); }

    function aiPlay() {
      if (G.over || G.turn !== 'ai') return;
      const hand = G.ai.hand.slice(); if (hand.length === 0) { endTurn(); return; }
      let idx = -1;
      if (G.you.space.length > 0 && hand.includes('S')) idx = hand.indexOf('S');
      if (idx < 0 && G.ai.discard.length > 0 && hand.includes('R')) idx = hand.indexOf('R');
      if (idx < 0 && hand.includes('F')) idx = hand.indexOf('F');
      if (idx < 0 && hand.includes('T')) idx = hand.indexOf('T');
      if (idx < 0 && hand.includes('I')) idx = hand.indexOf('I');
      if (idx < 0) idx = 0;
      const letter = hand[idx];
      if (G.traps.forbidAI === letter) {
        G.traps.forbidAI = null;
        const fake = document.createElement('div'); fake.className = 'card'; fake.appendChild(Object.assign(document.createElement('div'), { className: 'L ' + letter, textContent: letter }));
        document.getElementById('aiSpace').appendChild(fake);
        setTimeout(() => {
          animateFly(fake, document.getElementById('aiDiscard'));
          if (fake.parentNode) fake.parentNode.removeChild(fake);
        }, 50);
        G.ai.hand.splice(idx, 1); G.ai.discard.push(letter);
        logAdd(`Forbid: AI's ${letter} went to DISCARD.`);
        render(); if (!checkWin()) setTimeout(endTurn, 650); return;
      }
      G.ai.hand.splice(idx, 1); G.ai.space.push(letter);
      animateFly(null, document.getElementById('aiSpace'));
      logAdd(`AI played ${letter}.`); render();
      if (letter === 'F') {
        const tChosen = pickMostType(G.you.space) || TYPES[Math.floor(Math.random() * 5)];
        G.traps.forbidYou = tChosen; logAdd("AI forbade a letter for you."); render(); finalize(); return;
      }
      if (letter === 'I') { draw('ai', 1); finalize(); return; }
      if (letter === 'R') {
        if (G.ai.discard.length > 0) {
          const c = G.ai.discard.pop(); G.ai.hand.push(c);
          animateFromDiscardTo('ai', 'hand', c);
          logAdd(tt('recoverAI')); enforceHandLimit('ai');
        }
        finalize(); return;
      }
      if (letter === 'S') {
        if (G.you.space.length > 0) {
          const i = G.you.space.length - 1;
          animateFromSpaceOrHand('you', 'space', i, document.getElementById('youDiscard'));
          const removed = G.you.space.pop(); G.you.discard.push(removed);
          logAdd(`AI stole your ${removed} to your DISCARD.`); render();
        }
        finalize(); return;
      }
      if (letter === 'T') { G.traps.tNextYou++; logAdd(tt('tAI')); finalize(); return; }
      finalize();
      function finalize() { if (!checkWin()) endTurn(); }
    }

    function pickMostType(arr) { const m = {}; for (const x of arr) { m[x] = (m[x] || 0) + 1; } let b = null, v = -1; for (const [k, c] of Object.entries(m)) { if (c > v) { b = k; v = c; } } return b; }

    /* Dice */
    function openDiceAndDecideFirstPlayer() {
      const overlay = document.getElementById('diceOverlay'); overlay.style.display = 'flex';
      let you = rand1to6(), ai = rand1to6(); if (you === ai) { do { you = rand1to6(); ai = rand1to6(); } while (you === ai); }
      animateDice('dieYou', you); animateDice('dieAI', ai);
      setTimeout(() => {
        G.firstPlayer = you > ai ? 'you' : 'ai';
        overlay.style.display = 'none'; G.turn = G.firstPlayer; render(); startTurn();
      }, 1700);
    }
    function rand1to6() { return 1 + Math.floor(Math.random() * 6); }
    function animateDice(id, val) {
      const die = document.getElementById(id); const target = faceRotation(val);
      if (window.gsap && gsap.to) { const tl = gsap.timeline(); tl.to(die, { duration: 0.6, rotateX: 360, rotateY: 360, ease: "power2.out" }).to(die, { duration: 0.7, rotateX: target.x, rotateY: target.y, ease: "power3.out" }); }
      else { const t0 = performance.now(), dur = 700; function step(now) { const p = Math.min(1, (now - t0) / dur); const ex = target.x * p, ey = target.y * p; die.style.transform = `rotateX(${ex}deg) rotateY(${ey}deg)`; if (p < 1) requestAnimationFrame(step); } requestAnimationFrame(step); }
    }
    function faceRotation(v) { switch (v) { case 1: return { x: 0, y: 0 }; case 2: return { x: 0, y: -90 }; case 3: return { x: 0, y: 180 }; case 4: return { x: 0, y: 90 }; case 5: return { x: -90, y: 0 }; case 6: return { x: 90, y: 0 }; } return { x: 0, y: 0 }; }

    /* ===== Anim & helpers ===== */
    function pickHandCardEl(index) { const hand = document.getElementById('youHand'); return hand.children[index]; }
    function animateFly(fromEl, toContainer) {
      const rectTo = toContainer.getBoundingClientRect();
      let rectFrom;
      let ghost;
      if (fromEl) {
        rectFrom = fromEl.getBoundingClientRect();
        ghost = fromEl.cloneNode(true);
      } else {
        rectFrom = { left: rectTo.left, top: rectTo.top, width: 20, height: 20 };
        ghost = document.createElement('div'); ghost.className = 'card'; const s = document.createElement('div'); s.className = 'L'; s.textContent = ''; ghost.appendChild(s);
      }
      const targetX = rectTo.left + rectTo.width / 2 - (rectFrom.left + rectFrom.width / 2);
      const targetY = rectTo.top + rectTo.height / 2 - (rectFrom.top + rectFrom.height / 2);
      ghost.style.position = 'fixed'; ghost.style.left = (rectFrom.left) + 'px'; ghost.style.top = (rectFrom.top) + 'px'; ghost.style.margin = '0'; ghost.style.zIndex = '250'; ghost.style.pointerEvents = 'none';
      document.body.appendChild(ghost);
      const t0 = performance.now(), dur = 500; function step(now) { const p = Math.min(1, (now - t0) / dur); const x = targetX * p, y = targetY * p, s = 1 - 0.12 * p; ghost.style.transform = `translate(${x}px, ${y}px) scale(${s})`; if (p < 1) requestAnimationFrame(step); else document.body.removeChild(ghost); } requestAnimationFrame(step);
    }
    function animateForbidden(fromEl, spaceContainer, discardContainer, letter) {
      animateFly(fromEl, spaceContainer);
      setTimeout(() => {
        const fake = document.createElement('div'); fake.className = 'card'; const L = document.createElement('div'); L.className = 'L ' + letter; L.textContent = letter; fake.appendChild(L);
        const rectSpace = spaceContainer.getBoundingClientRect();
        fake.style.position = 'fixed'; fake.style.left = (rectSpace.left + 24) + 'px'; fake.style.top = (rectSpace.top + 24) + 'px'; fake.style.margin = '0'; fake.style.zIndex = '250'; fake.style.pointerEvents = 'none';
        document.body.appendChild(fake);
        animateFly(fake, discardContainer);
        setTimeout(() => { if (fake.parentNode) fake.parentNode.removeChild(fake); }, 520);
      }, 250);
    }
    function animateFromSpaceOrHand(side, area, index, targetContainer) {
      const zoneId = side === 'you' ? (area === 'space' ? 'youSpace' : 'youHand') : (area === 'space' ? 'aiSpace' : 'aiHandHidden');
      const zone = document.getElementById(zoneId);
      if (!zone) { return; }
      // in stacked layout, find the last stack with this index if space area
      let fromEl = null;
      if (area === 'space') {
        // flatten logical index into visual: map letters
        const letters = side === 'you' ? G.you.space : G.ai.space;
        const letter = letters[index];
        // find a stack with top card having same letter
        const stacks = Array.from(zone.querySelectorAll('.stack'));
        for (let i = stacks.length - 1; i >= 0; i--) {
          const top = stacks[i].querySelector('.card-top .L');
          if (top && top.textContent === letter) { fromEl = stacks[i].querySelector('.card-top'); break; }
        }
      } else {
        if (zone.children && zone.children[index]) fromEl = zone.children[index];
      }
      if (!fromEl) return; animateFly(fromEl, targetContainer);
    }
    function animateFromDiscardTo(side, dest, letter) {
      const from = document.getElementById(side === 'you' ? 'youDiscard' : 'aiDiscard');
      const to = document.getElementById(side === 'you' ? 'youHand' : 'aiSpace');
      if (!from || !to) return;
      const ghost = document.createElement('div'); ghost.className = 'card'; const L = document.createElement('div'); L.className = 'L ' + letter; L.textContent = letter; ghost.appendChild(L);
      const rectFrom = from.getBoundingClientRect();
      ghost.style.position = 'fixed'; ghost.style.left = (rectFrom.left + rectFrom.width * 0.3) + 'px'; ghost.style.top = (rectFrom.top + rectFrom.height * 0.3) + 'px'; ghost.style.zIndex = '250';
      document.body.appendChild(ghost);
      animateFly(ghost, to);
      setTimeout(() => { if (ghost.parentNode) ghost.parentNode.removeChild(ghost); }, 600);
    }

    /* ===== Layout helpers ===== */

    function computeAdaptiveCardWidth() {
      const root = document.documentElement;
      const handRow = document.getElementById('youHand');
      const headerH = document.querySelector('header').getBoundingClientRect().height;
      const grid = document.getElementById('boardGrid');
      // Available height for left column panels
      const vh = window.innerHeight;
      const leftCol = document.querySelector('.leftCol');
      const gaps = parseFloat(getComputedStyle(leftCol).gap || 8) * 2; // approx
      const panels = 3;
      const availForPanels = Math.max(200, vh - headerH - 24);
      const perPanel = (availForPanels - gaps) / panels;

      // From height: boardFlat height = cardW * zoneK + zoneC + inner paddings (~22)
      const cs = getComputedStyle(root);
      const zoneK = parseFloat(cs.getPropertyValue('--zone-k')) || 1.0;
      const zoneCpx = parseFloat((cs.getPropertyValue('--zone-c') || '0').replace('px', '')) || 16;
      const innerPad = 22; // title + insets approximation
      const maxFromHeight = Math.max(32, (perPanel - innerPad - zoneCpx) / Math.max(0.6, zoneK));

      // From width: hand should fit 7 cards without scroll
      // precise inner width = clientWidth - horizontal paddings
      const csRow = getComputedStyle(handRow);
      const padL = parseFloat(csRow.paddingLeft) || 0;
      const padR = parseFloat(csRow.paddingRight) || 0;
      const handW = (handRow.clientWidth - padL - padR) || (window.innerWidth * 0.9);
      const handGaps = 8 * 6; // 6 gaps by CSS
      const SAFETY = 6; // compensate borders/rounding to avoid overflow
      const fromHand = Math.max(26, Math.floor((handW - handGaps - SAFETY) / 7));

      // Base card variable (desktop cap keeps aesthetic)
      const base = Math.min(fromHand, maxFromHeight, 160);
      root.style.setProperty('--card-w', Math.floor(base) + 'px');
      // Hand cards may be slightly larger to fill row
      root.style.setProperty('--card-w-hand', Math.floor(fromHand) + 'px');
    }

    function fitHandToSeven() {
      const row = document.getElementById('youHand');
      const csRow = getComputedStyle(row);
      const w = row.clientWidth - (parseFloat(csRow.paddingLeft) || 0) - (parseFloat(csRow.paddingRight) || 0);
      const gaps = 8 * 6; let target = Math.floor((w - gaps - 6) / 7);
      if (window.innerWidth >= 700 && window.innerWidth <= 1180) { target = Math.floor(target * 1.08); }
      const max = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w').match(/\d+/));
      const cardW = Math.max(40, Math.min(target, Math.floor((max || 120) * 1.12)));
      document.documentElement.style.setProperty('--card-w-hand', cardW + 'px');
    }

    let scaleApplied = 1;




    function fitMobileScale() {
      const grid = document.getElementById('boardGrid');
      if (window.innerWidth >= 1000) { grid.style.transform = 'scale(1)'; scaleApplied = 1; return; }
      const headerH = document.querySelector('header').getBoundingClientRect().height;
      const safe = (window.visualViewport && window.visualViewport.height ? (window.innerHeight - window.visualViewport.height) : 0);
      const avail = window.innerHeight - headerH - 6 - safe; if (avail <= 0) return;
      grid.style.transform = 'scale(1)';
      const natural = grid.getBoundingClientRect().height;
      let s = Math.min(1, avail / natural);
      s = Math.max(0.58, Math.min(1, s));
      s = Math.round(s * 100) / 100;
      grid.style.transform = `scale(${s})`;
      scaleApplied = s;
    }

    /* ===== Choices, win check, menu & help ===== */
    function chooseType(title, options, cb) {
      const modal = document.getElementById('choiceModal');
      const ttl = document.getElementById('choiceTitle');
      const area = document.getElementById('choiceArea');
      if (!modal || !ttl || !area) return;
      ttl.textContent = tt('choose') + ': ' + title;
      area.innerHTML = '';
      options.forEach(o => {
        const b = document.createElement('button');
        b.className = 'btn';
        b.textContent = o;
        b.addEventListener('click', () => { modal.style.display = 'none'; cb(o); });
        area.appendChild(b);
      });
      modal.style.display = 'flex';
    }
    function chooseIndex(title, list, cb) {
      const modal = document.getElementById('choiceModal');
      const ttl = document.getElementById('choiceTitle');
      const area = document.getElementById('choiceArea');
      if (!modal || !ttl || !area) return;
      ttl.textContent = tt('choose') + ': ' + title;
      area.innerHTML = '';
      list.forEach((letter, idx) => {
        const b = document.createElement('button');
        b.className = 'btn';
        b.textContent = letter;
        b.addEventListener('click', () => { modal.style.display = 'none'; cb(idx); });
        area.appendChild(b);
      });
      modal.style.display = 'flex';
    }

    function updateRulesContent() {
      const rulesBody = document.getElementById('rulesMenuBody');
      if (rulesBody) rulesBody.innerHTML = tt('rulesBody');
      const rulesTitle = document.getElementById('rulesMenuTitle');
      if (rulesTitle) rulesTitle.textContent = tt('rulesMenuTitle');
      const rulesLangBtn = document.getElementById('rulesLangBtn');
      if (rulesLangBtn) rulesLangBtn.textContent = LANG === 'en' ? '🇬🇧 EN' : '🇷🇺 RU';
    }

    function on(id, ev, fn) { const el = document.getElementById(id); if (el) el.addEventListener(ev, fn); }
    function setupEvents() {
      on('menuNewGame', 'click', () => { const m = document.getElementById('menu'); if (m) m.style.display = 'none'; newGame(); });
      on('menuRules', 'click', () => { 
        const m = document.getElementById('menu'); if (m) m.style.display = 'none'; 
        const r = document.getElementById('rulesMenu'); if (r) r.style.display = 'flex';
        // Принудительно обновляем содержимое правил
        updateRulesContent();
      });
      on('backToMenu', 'click', () => { const r = document.getElementById('rulesMenu'); if (r) r.style.display = 'none'; const m = document.getElementById('menu'); if (m) m.style.display = 'flex'; });
      on('rulesLangBtn', 'click', () => { 
        LANG = (LANG === 'en') ? 'ru' : 'en'; 
        updateRulesContent();
        applyTexts();
      });
      on('toMenuBtn', 'click', () => { const m = document.getElementById('menu'); if (m) m.style.display = 'flex'; });
      on('restartBtn', 'click', () => { newGame(); });
      on('helpBtn', 'click', () => { const h = document.getElementById('helpModal'); if (h) h.style.display = 'flex'; });
      on('closeHelp', 'click', () => { const h = document.getElementById('helpModal'); if (h) h.style.display = 'none'; });
      on('winClose', 'click', () => { const w = document.getElementById('winModal'); if (w) w.style.display = 'none'; });
      on('winMenu', 'click', () => { const w = document.getElementById('winModal'); if (w) w.style.display = 'none'; const m = document.getElementById('menu'); if (m) m.style.display = 'flex'; });
      on('winNew', 'click', () => { const w = document.getElementById('winModal'); if (w) w.style.display = 'none'; newGame(); });
      on('langBtn', 'click', () => { LANG = (LANG === 'en') ? 'ru' : 'en'; applyTexts(); render(); });
      on('toggleLog', 'click', () => { const p = document.getElementById('logPanel'); if (p) { p.classList.toggle('collapsed'); applyTexts(); } });
      // Hamburger
      const burger = document.getElementById('hamburger');
      const qMenu = document.getElementById('quickMenu');
      if (burger && qMenu) {
        burger.addEventListener('click', (e) => { e.stopPropagation(); qMenu.style.display = (qMenu.style.display === 'flex') ? 'none' : 'flex'; });
        document.addEventListener('click', () => { if (qMenu.style.display === 'flex') qMenu.style.display = 'none'; });
      }
      on('qmLang', 'click', (e) => { e.stopPropagation(); LANG = (LANG === 'en') ? 'ru' : 'en'; applyTexts(); render(); });
      on('qmRules', 'click', (e) => { e.stopPropagation(); const h = document.getElementById('helpModal'); if (h) h.style.display = 'flex'; });
      on('qmNew', 'click', (e) => { e.stopPropagation(); newGame(); });
      on('qmFull', 'click', (e) => { e.stopPropagation(); if (document.documentElement.requestFullscreen) { document.documentElement.requestFullscreen(); } });
    }
    // boot after DOM ready
    (function () {
      const boot = () => { 
        try { 
          computeAdaptiveCardWidth(); 
          fitHandToSeven(); 
          fitMobileScale(); 
          setupEvents(); 
          applyTexts(); // Инициализируем тексты при загрузке
          render(); 
          // Toggle active state for menu circles on tap/click (mobile friendly)
          document.querySelectorAll('.menu-card').forEach((el) => {
            el.addEventListener('click', (ev) => {
              ev.stopPropagation();
              el.classList.toggle('menu-card-active');
            });
          });
        } catch (e) { console.error(e); } 
      };
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot, { once: true });
      else boot();
    })();

  </script>
</body>

</html>
