<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F!RST Game Integration Tests</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0c1014;
            color: #f2f5fb;
            padding: 20px;
            line-height: 1.6;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid;
        }
        .test-pass {
            background: #1a3d2e;
            border-color: #4ade80;
            color: #a9ffcf;
        }
        .test-fail {
            background: #3d1a1a;
            border-color: #ef4444;
            color: #ff9aa4;
        }
        .test-group {
            margin: 20px 0;
            border: 1px solid #2a3550;
            border-radius: 8px;
            padding: 15px;
            background: #16213a;
        }
        .test-group h3 {
            color: #9cc8ff;
            margin-top: 0;
        }
        .summary {
            background: #232b39;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        .load-game-btn {
            background: #1a2738;
            color: #e8f0ff;
            border: 1px solid #3a4a6a;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
        }
        .load-game-btn:hover {
            background: #1f2d42;
        }
        iframe {
            width: 100%;
            height: 400px;
            border: 1px solid #2a3550;
            border-radius: 8px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>🔗 F!RST Game Integration Tests</h1>
        
        <div class="summary">
            <h2>Integration Testing with Actual Game Code</h2>
            <p>These tests verify that the actual game implementation matches the expected behavior.</p>
            <button class="load-game-btn" onclick="loadGame()">Load Game for Testing</button>
            <button class="load-game-btn" onclick="runIntegrationTests()">Run Integration Tests</button>
        </div>

        <iframe id="gameFrame" src="../first_in_progress.html"></iframe>
        
        <div id="test-results"></div>
    </div>

    <script>
        let gameWindow = null;
        let testResults = [];

        function loadGame() {
            const iframe = document.getElementById('gameFrame');
            iframe.style.display = 'block';
            iframe.onload = () => {
                gameWindow = iframe.contentWindow;
                console.log('Game loaded successfully');
            };
        }

        async function runIntegrationTests() {
            if (!gameWindow) {
                alert('Please load the game first!');
                return;
            }

            testResults = [];
            const resultsContainer = document.getElementById('test-results');
            resultsContainer.innerHTML = '<div class="test-group"><h3>Running Integration Tests...</h3></div>';

            try {
                await testGameInitialization();
                await testCardEffects();
                await testWinConditions();
                await testTrapMechanics();
                await testForbidMechanics();
                await testHandLimit();
                await testTurnFlow();
                
                displayResults();
            } catch (error) {
                resultsContainer.innerHTML += `
                    <div class="test-result test-fail">
                        <strong>Integration Test Error:</strong> ${error.message}
                    </div>
                `;
            }
        }

        function addTestResult(group, test, passed, error = null) {
            testResults.push({ group, test, passed, error });
        }

        async function testGameInitialization() {
            try {
                // Test if game constants are correct
                const TYPES = gameWindow.TYPES;
                addTestResult('Initialization', 'TYPES constant should contain F,I,R,S,T', 
                    TYPES && TYPES.length === 5 && TYPES.includes('F') && TYPES.includes('I') && 
                    TYPES.includes('R') && TYPES.includes('S') && TYPES.includes('T'));

                // Test deck building
                const deck = gameWindow.buildDeck ? gameWindow.buildDeck() : null;
                addTestResult('Initialization', 'buildDeck should create 50 cards', 
                    deck && deck.length === 50);

                if (deck) {
                    const counts = { F: 0, I: 0, R: 0, S: 0, T: 0 };
                    deck.forEach(card => counts[card]++);
                    addTestResult('Initialization', 'Deck should have 10 of each card type',
                        counts.F === 10 && counts.I === 10 && counts.R === 10 && 
                        counts.S === 10 && counts.T === 10);
                }

                // Test game state structure
                if (gameWindow.G) {
                    const G = gameWindow.G;
                    addTestResult('Initialization', 'Game state should have required properties',
                        G.hasOwnProperty('you') && G.hasOwnProperty('ai') && 
                        G.hasOwnProperty('traps') && G.hasOwnProperty('turn'));
                }

            } catch (error) {
                addTestResult('Initialization', 'Error accessing game functions', false, error.message);
            }
        }

        async function testCardEffects() {
            try {
                // Test if resolveEffect function exists
                addTestResult('Card Effects', 'resolveEffect function should exist',
                    typeof gameWindow.resolveEffect === 'function');

                // Test win condition checking
                addTestResult('Card Effects', 'checkWin function should exist',
                    typeof gameWindow.checkWin === 'function');

                // Test if card effect constants are defined
                if (gameWindow.G && gameWindow.G.traps) {
                    addTestResult('Card Effects', 'Trap state should have forbid properties',
                        gameWindow.G.traps.hasOwnProperty('forbidYou') && 
                        gameWindow.G.traps.hasOwnProperty('forbidAI'));
                    
                    addTestResult('Card Effects', 'Trap state should have trap counters',
                        gameWindow.G.traps.hasOwnProperty('tNextYou') && 
                        gameWindow.G.traps.hasOwnProperty('tNextAI'));
                }

            } catch (error) {
                addTestResult('Card Effects', 'Error testing card effects', false, error.message);
            }
        }

        async function testWinConditions() {
            try {
                if (gameWindow.checkWin && gameWindow.G) {
                    // Temporarily modify game state to test win conditions
                    const originalYouSpace = [...gameWindow.G.you.space];
                    const originalAISpace = [...gameWindow.G.ai.space];

                    // Test F-I-R-S-T win condition
                    gameWindow.G.you.space = ['F', 'I', 'R', 'S', 'T'];
                    const firstResult = gameWindow.checkWin();
                    addTestResult('Win Conditions', 'Should detect F-I-R-S-T sequence win', firstResult);

                    // Test 5 of a kind win condition
                    gameWindow.G.you.space = ['F', 'F', 'F', 'F', 'F'];
                    const fiveResult = gameWindow.checkWin();
                    addTestResult('Win Conditions', 'Should detect 5 of a kind win', fiveResult);

                    // Test no win condition
                    gameWindow.G.you.space = ['F', 'I', 'R'];
                    gameWindow.G.ai.space = ['S', 'T'];
                    const noWinResult = gameWindow.checkWin();
                    addTestResult('Win Conditions', 'Should not detect win with incomplete sets', !noWinResult);

                    // Restore original state
                    gameWindow.G.you.space = originalYouSpace;
                    gameWindow.G.ai.space = originalAISpace;
                }
            } catch (error) {
                addTestResult('Win Conditions', 'Error testing win conditions', false, error.message);
            }
        }

        async function testTrapMechanics() {
            try {
                if (gameWindow.G && gameWindow.G.traps) {
                    // Test trap counter initialization
                    addTestResult('Trap Mechanics', 'Trap counters should be numbers',
                        typeof gameWindow.G.traps.tNextYou === 'number' && 
                        typeof gameWindow.G.traps.tNextAI === 'number');

                    // Test that traps start at 0
                    const trapsStartAtZero = gameWindow.G.traps.tNextYou >= 0 && 
                                           gameWindow.G.traps.tNextAI >= 0;
                    addTestResult('Trap Mechanics', 'Trap counters should start at 0 or positive', trapsStartAtZero);
                }

                // Test if startTurn function handles traps
                addTestResult('Trap Mechanics', 'startTurn function should exist',
                    typeof gameWindow.startTurn === 'function');

            } catch (error) {
                addTestResult('Trap Mechanics', 'Error testing trap mechanics', false, error.message);
            }
        }

        async function testForbidMechanics() {
            try {
                if (gameWindow.G && gameWindow.G.traps) {
                    // Test forbid state initialization
                    const forbidPropsExist = gameWindow.G.traps.hasOwnProperty('forbidYou') && 
                                           gameWindow.G.traps.hasOwnProperty('forbidAI');
                    addTestResult('Forbid Mechanics', 'Forbid properties should exist', forbidPropsExist);

                    // Test that forbid starts as null
                    const forbidStartsNull = gameWindow.G.traps.forbidYou === null && 
                                           gameWindow.G.traps.forbidAI === null;
                    addTestResult('Forbid Mechanics', 'Forbid should start as null', forbidStartsNull);
                }

                // Test if playFromHand function exists (handles forbid logic)
                addTestResult('Forbid Mechanics', 'playFromHand function should exist',
                    typeof gameWindow.playFromHand === 'function');

            } catch (error) {
                addTestResult('Forbid Mechanics', 'Error testing forbid mechanics', false, error.message);
            }
        }

        async function testHandLimit() {
            try {
                // Test if enforceHandLimit function exists
                addTestResult('Hand Limit', 'enforceHandLimit function should exist',
                    typeof gameWindow.enforceHandLimit === 'function');

                if (gameWindow.G && gameWindow.enforceHandLimit) {
                    // Test hand limit enforcement
                    const originalHand = [...gameWindow.G.you.hand];
                    const originalDiscard = [...gameWindow.G.you.discard];

                    // Temporarily give player too many cards
                    gameWindow.G.you.hand = ['F', 'I', 'R', 'S', 'T', 'F', 'I', 'R', 'S']; // 9 cards
                    gameWindow.enforceHandLimit('you');

                    const handLimitEnforced = gameWindow.G.you.hand.length <= 7;
                    addTestResult('Hand Limit', 'Hand should be limited to 7 cards', handLimitEnforced);

                    // Restore original state
                    gameWindow.G.you.hand = originalHand;
                    gameWindow.G.you.discard = originalDiscard;
                }

            } catch (error) {
                addTestResult('Hand Limit', 'Error testing hand limit', false, error.message);
            }
        }

        async function testTurnFlow() {
            try {
                // Test if turn management functions exist
                addTestResult('Turn Flow', 'startTurn function should exist',
                    typeof gameWindow.startTurn === 'function');
                
                addTestResult('Turn Flow', 'endTurn function should exist',
                    typeof gameWindow.endTurn === 'function');

                // Test if game state tracks turns properly
                if (gameWindow.G) {
                    addTestResult('Turn Flow', 'Game should track current turn',
                        gameWindow.G.hasOwnProperty('turn'));
                    
                    addTestResult('Turn Flow', 'Game should track first player',
                        gameWindow.G.hasOwnProperty('firstPlayer'));
                    
                    addTestResult('Turn Flow', 'Game should track first turn completion',
                        gameWindow.G.hasOwnProperty('firstTurnDone'));
                }

                // Test if draw function exists
                addTestResult('Turn Flow', 'draw function should exist',
                    typeof gameWindow.draw === 'function');

            } catch (error) {
                addTestResult('Turn Flow', 'Error testing turn flow', false, error.message);
            }
        }

        function displayResults() {
            const resultsContainer = document.getElementById('test-results');
            const groups = {};
            
            // Group results
            testResults.forEach(result => {
                if (!groups[result.group]) {
                    groups[result.group] = [];
                }
                groups[result.group].push(result);
            });

            // Calculate totals
            const totalTests = testResults.length;
            const passedTests = testResults.filter(r => r.passed).length;
            const failedTests = totalTests - passedTests;

            // Display summary
            let html = `
                <div class="summary ${failedTests === 0 ? 'test-pass' : 'test-fail'}">
                    <h2>Integration Test Results</h2>
                    <div style="font-size: 24px; margin: 10px 0;">
                        <span style="color: #4ade80;">✓ ${passedTests}</span> | 
                        <span style="color: #ef4444;">✗ ${failedTests}</span> | 
                        <span style="color: #9cc8ff;">${((passedTests/totalTests)*100).toFixed(1)}%</span>
                    </div>
                    <div>${failedTests === 0 ? '🎉 All integration tests passed!' : '⚠️ Some integration tests failed'}</div>
                </div>
            `;

            // Display grouped results
            Object.entries(groups).forEach(([groupName, tests]) => {
                const groupPassed = tests.filter(t => t.passed).length;
                const groupTotal = tests.length;
                
                html += `
                    <div class="test-group">
                        <h3>${groupName} (${groupPassed}/${groupTotal})</h3>
                        ${tests.map(test => `
                            <div class="test-result ${test.passed ? 'test-pass' : 'test-fail'}">
                                <strong>${test.passed ? '✓' : '✗'} ${test.test}</strong>
                                ${test.error ? `<div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">Error: ${test.error}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            });

            resultsContainer.innerHTML = html;
        }
    </script>
</body>
</html>